--- mobx.js	2020-10-02 17:33:31.856603978 +0300
+++ mobx.js.new	2020-10-02 17:34:14.712947371 +0300
@@ -113,8 +113,8 @@
 function getNextId() {
   return ++globalState.mobxGuid;
 }
-/**
- * Makes sure that the provided function is invoked at most once.
+/**
+ * Makes sure that the provided function is invoked at most once.
  */
 
 function once(func) {
@@ -195,8 +195,8 @@
   return thing instanceof Set;
 }
 var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
-/**
- * Returns the following: own keys, prototype keys & own symbol keys, if they are enumerable.
+/**
+ * Returns the following: own keys, prototype keys & own symbol keys, if they are enumerable.
  */
 
 function getPlainObjectKeys(object) {
@@ -316,9 +316,9 @@
 var Atom = /*#__PURE__*/function () {
   // for effective unobserving. BaseAtom has true, for extra optimization, so its onBecomeUnobserved never gets called, because it's not needed
 
-  /**
-   * Create a new atom. For debugging purposes it is recommended to give it a name.
-   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
+  /**
+   * Create a new atom. For debugging purposes it is recommended to give it a name.
+   * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
    */
   function Atom(name_) {
     if (name_ === void 0) {
@@ -355,17 +355,17 @@
       });
     }
   }
-  /**
-   * Invoke this method to notify mobx that your atom has been used somehow.
-   * Returns true if there is currently a reactive context.
+  /**
+   * Invoke this method to notify mobx that your atom has been used somehow.
+   * Returns true if there is currently a reactive context.
    */
   ;
 
   _proto.reportObserved = function reportObserved$1() {
     return reportObserved(this);
   }
-  /**
-   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
+  /**
+   * Invoke this method _after_ this method has changed to signal mobx that all its observers should invalidate.
    */
   ;
 
@@ -502,9 +502,9 @@
 
   return !annotation ? deepEnhancer : (_annotationToEnhancer2 = annotationToEnhancer[annotation.annotationType_]) !== null && _annotationToEnhancer2 !== void 0 ? _annotationToEnhancer2 : die(12);
 }
-/**
- * Turns an object, array or function into a reactive structure.
- * @param v the value which should become observable.
+/**
+ * Turns an object, array or function into a reactive structure.
+ * @param v the value which should become observable.
  */
 
 function createObservable(v, arg2, arg3) {
@@ -557,9 +557,9 @@
 
 var COMPUTED = "computed";
 var COMPUTED_STRUCT = "computed.struct";
-/**
- * Decorator for class properties: @computed get value() { return expr; }.
- * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
+/**
+ * Decorator for class properties: @computed get value() { return expr; }.
+ * For legacy purposes also invokable as ES5 observable created: `computed(() => expr)`;
  */
 
 var computed = function computed(arg1, arg2, arg3) {
@@ -972,24 +972,24 @@
 var isObservableValue = /*#__PURE__*/createInstanceofPredicate("ObservableValue", ObservableValue);
 
 var _Symbol$toPrimitive$1;
-/**
- * A node in the state dependency root that observes other nodes, and can be observed itself.
- *
- * ComputedValue will remember the result of the computation for the duration of the batch, or
- * while being observed.
- *
- * During this time it will recompute only when one of its direct dependencies changed,
- * but only when it is being accessed with `ComputedValue.get()`.
- *
- * Implementation description:
- * 1. First time it's being accessed it will compute and remember result
- *    give back remembered result until 2. happens
- * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
- * 3. When it's being accessed, recompute if any shallow dependency changed.
- *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
- *    go to step 2. either way
- *
- * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
+/**
+ * A node in the state dependency root that observes other nodes, and can be observed itself.
+ *
+ * ComputedValue will remember the result of the computation for the duration of the batch, or
+ * while being observed.
+ *
+ * During this time it will recompute only when one of its direct dependencies changed,
+ * but only when it is being accessed with `ComputedValue.get()`.
+ *
+ * Implementation description:
+ * 1. First time it's being accessed it will compute and remember result
+ *    give back remembered result until 2. happens
+ * 2. First time any deep dependency change, propagate POSSIBLY_STALE to all observers, wait for 3.
+ * 3. When it's being accessed, recompute if any shallow dependency changed.
+ *    if result changed: propagate STALE to all observers, that were POSSIBLY_STALE from the last step.
+ *    go to step 2. either way
+ *
+ * If at any point it's outside batch and it isn't observed: reset everything and go to 1.
  */
 
 _Symbol$toPrimitive$1 = Symbol.toPrimitive;
@@ -999,17 +999,17 @@
   // to check for cycles
   // N.B: unminified as it is used by MST
 
-  /**
-   * Create a new computed value based on a function expression.
-   *
-   * The `name` property is for debug purposes only.
-   *
-   * The `equals` property specifies the comparer function to use to determine if a newly produced
-   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
-   * compares based on identity comparison (===), and `structualComparer` deeply compares the structure.
-   * Structural comparison can be convenient if you always produce a new aggregated object and
-   * don't want to notify observers if it is structurally the same.
-   * This is useful for working with vectors, mouse coordinates etc.
+  /**
+   * Create a new computed value based on a function expression.
+   *
+   * The `name` property is for debug purposes only.
+   *
+   * The `equals` property specifies the comparer function to use to determine if a newly produced
+   * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
+   * compares based on identity comparison (===), and `structualComparer` deeply compares the structure.
+   * Structural comparison can be convenient if you always produce a new aggregated object and
+   * don't want to notify observers if it is structurally the same.
+   * This is useful for working with vectors, mouse coordinates etc.
    */
   function ComputedValue(options) {
     this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
@@ -1069,9 +1069,9 @@
       });
     }
   }
-  /**
-   * Returns the current value of this computed value.
-   * Will evaluate its computation first if needed.
+  /**
+   * Returns the current value of this computed value.
+   * Will evaluate its computation first if needed.
    */
   ;
 
@@ -1272,16 +1272,16 @@
 function isCaughtException(e) {
   return e instanceof CaughtException;
 }
-/**
- * Finds out whether any dependency of the derivation has actually changed.
- * If dependenciesState is 1 then it will recalculate dependencies,
- * if any dependency changed it will propagate it by changing dependenciesState to 2.
- *
- * By iterating over the dependencies in the same order that they were reported and
- * stopping on the first change, all the recalculations are only called for ComputedValues
- * that will be tracked by derivation. That is because we assume that if the first x
- * dependencies of the derivation doesn't change then the derivation should run the same way
- * up until accessing x-th dependency.
+/**
+ * Finds out whether any dependency of the derivation has actually changed.
+ * If dependenciesState is 1 then it will recalculate dependencies,
+ * if any dependency changed it will propagate it by changing dependenciesState to 2.
+ *
+ * By iterating over the dependencies in the same order that they were reported and
+ * stopping on the first change, all the recalculations are only called for ComputedValues
+ * that will be tracked by derivation. That is because we assume that if the first x
+ * dependencies of the derivation doesn't change then the derivation should run the same way
+ * up until accessing x-th dependency.
  */
 
 function shouldCompute(derivation) {
@@ -1354,10 +1354,10 @@
     console.warn("[mobx] Observable " + observable.name_ + " being read outside a reactive context");
   }
 }
-/**
- * Executes the provided function `f` and tracks which observables are being accessed.
- * The tracking information is stored on the `derivation` object and the derivation is registered
- * as observer of any of the accessed observables.
+/**
+ * Executes the provided function `f` and tracks which observables are being accessed.
+ * The tracking information is stored on the `derivation` object and the derivation is registered
+ * as observer of any of the accessed observables.
  */
 
 function trackDerivedFunction(derivation, f, context) {
@@ -1399,10 +1399,10 @@
     console.warn("[mobx] Derivation " + derivation.name_ + " is created/updated without reading any observable value");
   }
 }
-/**
- * diffs newObserving with observing.
- * update observing to be newObserving with unique observables
- * notify observers that become observed/unobserved
+/**
+ * diffs newObserving with observing.
+ * update observing to be newObserving with unique observables
+ * notify observers that become observed/unobserved
  */
 
 
@@ -1508,9 +1508,9 @@
 function allowStateReadsEnd(prev) {
   globalState.allowStateReads = prev;
 }
-/**
- * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
- *
+/**
+ * needed to keep `lowestObserverState` correct. when changing from (2 or 1) to 0
+ *
  */
 
 function changeDependenciesStateTo0(derivation) {
@@ -1524,8 +1524,8 @@
   }
 }
 
-/**
- * These values will persist if global state is reset
+/**
+ * These values will persist if global state is reset
  */
 
 var persistentKeys = ["mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies"];
@@ -1590,9 +1590,9 @@
 function getGlobalState() {
   return globalState;
 }
-/**
- * For testing purposes only; this will break the internal state of existing observables,
- * but can be used to get back at a stable state after throwing errors
+/**
+ * For testing purposes only; this will break the internal state of existing observables,
+ * but can be used to get back at a stable state after throwing errors
  */
 
 function resetGlobalState() {
@@ -1656,10 +1656,10 @@
     globalState.pendingUnobservations.push(observable);
   }
 }
-/**
- * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
- * During a batch `onBecomeUnobserved` will be called at most once per observable.
- * Avoids unnecessary recalculations.
+/**
+ * Batch starts a transaction, at least for purposes of memoizing ComputedValues when nothing else does.
+ * During a batch `onBecomeUnobserved` will be called at most once per observable.
+ * Avoids unnecessary recalculations.
  */
 
 function startBatch() {
@@ -1698,10 +1698,10 @@
   var derivation = globalState.trackingDerivation;
 
   if (derivation !== null) {
-    /**
-     * Simple optimization, give each derivation run an unique id (runId)
-     * Check if last time this observable was accessed the same runId is used
-     * if this is the case, the relation is already known
+    /**
+     * Simple optimization, give each derivation run an unique id (runId)
+     * Check if last time this observable was accessed the same runId is used
+     * if this is the case, the relation is already known
      */
     if (derivation.runId_ !== observable.lastAccessedBy_) {
       observable.lastAccessedBy_ = derivation.runId_; // Tried storing newObserving, or observing, or both as Set, but performance didn't come close...
@@ -1734,12 +1734,12 @@
 //     )
 // }
 
-/**
- * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
- * It will propagate changes to observers from previous run
- * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
- * Hopefully self reruning autoruns aren't a feature people should depend on
- * Also most basic use cases should be ok
+/**
+ * NOTE: current propagation mechanism will in case of self reruning autoruns behave unexpectedly
+ * It will propagate changes to observers from previous run
+ * It's hard or maybe impossible (with reasonable perf) to get it right with current approach
+ * Hopefully self reruning autoruns aren't a feature people should depend on
+ * Also most basic use cases should be ok
  */
 // Called by Atom when its value changes
 
@@ -1862,8 +1862,8 @@
   _proto.isScheduled = function isScheduled() {
     return this.isScheduled_;
   }
-  /**
-   * internal, use schedule() if you intend to kick off a reaction
+  /**
+   * internal, use schedule() if you intend to kick off a reaction
    */
   ;
 
@@ -2007,10 +2007,10 @@
     if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);
   };
 }
-/**
- * Magic number alert!
- * Defines within how many times a reaction is allowed to re-trigger itself
- * until it is assumed that this is gonna be a never ending loop...
+/**
+ * Magic number alert!
+ * Defines within how many times a reaction is allowed to re-trigger itself
+ * until it is assumed that this is gonna be a never ending loop...
  */
 
 var MAX_REACTION_ITERATIONS = 100;
@@ -2146,11 +2146,11 @@
   return isFunction(thing) && thing.isMobxAction === true;
 }
 
-/**
- * Creates a named reactive view and keeps it alive, so that the view is always
- * updated if one of the dependencies changes, even when the view is not further used by something else.
- * @param view The reactive view
- * @returns disposer function, which can be used to stop the view from being updated in the future.
+/**
+ * Creates a named reactive view and keeps it alive, so that the view is always
+ * updated if one of the dependencies changes, even when the view is not further used by something else.
+ * @param view The reactive view
+ * @returns disposer function, which can be used to stop the view from being updated in the future.
  */
 
 function autorun(view, opts) {
@@ -2777,8 +2777,8 @@
     return _res3;
   }
 }
-/**
- * Basically, a deep clone, so that no reactive property will exist anymore.
+/**
+ * Basically, a deep clone, so that no reactive property will exist anymore.
  */
 
 
@@ -2822,12 +2822,12 @@
   }
 }
 
-/**
- * During a transaction no views are updated until the end of the transaction.
- * The transaction will be run synchronously nonetheless.
- *
- * @param action a function that updates some reactive state
- * @returns any value that was returned by the 'action' parameter.
+/**
+ * During a transaction no views are updated until the end of the transaction.
+ * The transaction will be run synchronously nonetheless.
+ *
+ * @param action a function that updates some reactive state
+ * @returns any value that was returned by the 'action' parameter.
  */
 
 function transaction(action, thisArg) {
@@ -3541,11 +3541,11 @@
     return this.slice();
   },
 
-  /*
-   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
-   * since these functions alter the inner structure of the array, the have side effects.
-   * Because the have side effects, they should not be used in computed function,
-   * and for that reason the do not call dependencyState.notifyObserved
+  /*
+   * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
+   * since these functions alter the inner structure of the array, the have side effects.
+   * Because the have side effects, they should not be used in computed function,
+   * and for that reason the do not call dependencyState.notifyObserved
    */
   splice: function splice(index, deleteCount) {
     for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
@@ -3630,10 +3630,10 @@
     return false;
   }
 };
-/**
- * Wrap function from prototype
- * Without this, everything works as well, but this works
- * faster as everything works on unproxied values
+/**
+ * Wrap function from prototype
+ * Without this, everything works as well, but this works
+ * faster as everything works on unproxied values
  */
 
 addArrayExtension("concat", simpleFunc);
@@ -4118,10 +4118,10 @@
     return Array.from(this);
   };
 
-  /**
-   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
-   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
-   * for callback details
+  /**
+   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
+   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
+   * for callback details
    */
   _proto.observe_ = function observe_(listener, fireImmediately) {
     if (process.env.NODE_ENV !== "production" && fireImmediately === true) die("`observe` doesn't support fireImmediately=true in combination with maps.");
@@ -4601,10 +4601,10 @@
       endBatch();
     }
   }
-  /**
-   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
-   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
-   * for callback details
+  /**
+   * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
+   * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
+   * for callback details
    */
   ;
 
@@ -4721,10 +4721,10 @@
   return false;
 }
 
-/**
- * This array buffer contains two lists of properties, so that all arrays
- * can recycle their property definitions, which significantly improves performance of creating
- * properties on the fly.
+/**
+ * This array buffer contains two lists of properties, so that all arrays
+ * can recycle their property definitions, which significantly improves performance of creating
+ * properties on the fly.
  */
 
 var OBSERVABLE_ARRAY_BUFFER_SIZE = 0; // Typescript workaround to make sure ObservableArray extends Array
@@ -5064,22 +5064,22 @@
   return this;
 }
 
-/**
- * (c) Michel Weststrate 2015 - 2020
- * MIT Licensed
- *
- * Welcome to the mobx sources! To get an global overview of how MobX internally works,
- * this is a good place to start:
- * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
- *
- * Source folders:
- * ===============
- *
- * - api/     Most of the public static methods exposed by the module can be found here.
- * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
- * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
- * - utils/   Utility stuff.
- *
+/**
+ * (c) Michel Weststrate 2015 - 2020
+ * MIT Licensed
+ *
+ * Welcome to the mobx sources! To get an global overview of how MobX internally works,
+ * this is a good place to start:
+ * https://medium.com/@mweststrate/becoming-fully-reactive-an-in-depth-explanation-of-mobservable-55995262a254#.xvbh6qd74
+ *
+ * Source folders:
+ * ===============
+ *
+ * - api/     Most of the public static methods exposed by the module can be found here.
+ * - core/    Implementation of the MobX algorithm; atoms, derivations, reactions, dependency trees, optimizations. Cool stuff can be found here.
+ * - types/   All the magic that is need to have observable objects, arrays and values is in this folder. Including the modifiers like `asFlat`.
+ * - utils/   Utility stuff.
+ *
  */
 ["Symbol", "Map", "Set", "Symbol"].forEach(function (m) {
   var g = getGlobal();
@@ -5101,4 +5101,3 @@
 }
 
 export { $mobx, FlowCancellationError, ObservableMap, ObservableSet, Reaction, allowStateChanges as _allowStateChanges, runInAction as _allowStateChangesInsideComputed, allowStateReadsEnd as _allowStateReadsEnd, allowStateReadsStart as _allowStateReadsStart, autoAction as _autoAction, _endAction, getAdministration as _getAdministration, getGlobalState as _getGlobalState, interceptReads as _interceptReads, isComputingDerivation as _isComputingDerivation, resetGlobalState as _resetGlobalState, _startAction, action, autorun, comparer, computed, configure, createAtom, entries, extendObservable, flow, flowResult, get, getAtom, getDebugName, getDependencyTree, getObserverTree, has, intercept, isAction, isObservableValue as isBoxedObservable, isComputed, isComputedProp, isFlowCancellationError, isObservable, isObservableArray, isObservableMap, isObservableObject, isObservableProp, isObservableSet, keys, makeAutoObservable, makeObservable, observable, observe, onBecomeObserved, onBecomeUnobserved, onReactionError, reaction, remove, runInAction, set, spy, toJS, trace, transaction, untracked, values, when };
-//# sourceMappingURL=mobx.esm.js.map
